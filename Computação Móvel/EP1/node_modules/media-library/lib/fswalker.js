(function() {
  var FQueue, FSWalker, defaultOptions, fs, path,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  path = require('path');

  fs = require('fs');

  FQueue = require('./fqueue');

  defaultOptions = {
    concurrency: 10
  };

  FSWalker = (function(superClass) {
    extend(FSWalker, superClass);

    function FSWalker(rootPath, options) {
      if (!(this instanceof FSWalker)) {
        return new FSWalker(rootPath, options);
      }
      this.rootPath = rootPath;
      options = Object.assign({}, defaultOptions, options);
      FSWalker.__super__.constructor.call(this, options);
    }

    FSWalker.prototype.start = function() {
      return fs.readdir(this.rootPath, (function(_this) {
        return function(error, files) {
          if (error) {
            _this.emit('error', error);
            return _this.emit('done');
          } else {
            return _this._processFiles(files);
          }
        };
      })(this));
    };

    FSWalker.prototype._relativePath = function(p) {
      return path.relative(this.rootPath, p);
    };

    FSWalker.prototype._emitFile = function(fullPath, stats) {
      return this.emit('file', fullPath, stats, this._relativePath(fullPath));
    };

    FSWalker.prototype._emitDirectory = function(fullPath, stats) {
      return this.emit('directory', fullPath, stats, this._relativePath(fullPath));
    };

    FSWalker.prototype._emitError = function(error) {
      return this.emit('error', error);
    };

    FSWalker.prototype._processFiles = function(files) {
      var file, i, len, processFile, results, self;
      self = this;
      processFile = function(childPath, callback) {
        return fs.stat(childPath, function(error, stats) {
          if (error) {
            self._emitError(error);
            return callback(error);
          } else if (stats.isFile()) {
            self._emitFile(childPath, stats);
            return callback();
          } else if (stats.isDirectory()) {
            self._emitDirectory(childPath, stats);
            return fs.readdir(childPath, function(error, files) {
              var file, i, len;
              if (error) {
                self._emitError(error);
                return callback(error);
              } else {
                for (i = 0, len = files.length; i < len; i++) {
                  file = files[i];
                  self.unshift({
                    func: processFile,
                    args: [path.join(childPath, file)]
                  });
                }
                return callback();
              }
            });
          } else {
            return callback();
          }
        });
      };
      results = [];
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        results.push(self.push({
          func: processFile,
          args: [path.join(self.rootPath, file)]
        }));
      }
      return results;
    };

    return FSWalker;

  })(FQueue);

  module.exports = FSWalker;

}).call(this);
