path = require 'path'
fs = require 'fs'
FQueue = require './fqueue'

defaultOptions =
  concurrency: 10

class FSWalker extends FQueue
  constructor: (rootPath, options) ->
    if this not instanceof FSWalker
      return new FSWalker(rootPath, options)

    @rootPath = rootPath
    options = Object.assign({}, defaultOptions, options)
    super(options)

  start: ->
    fs.readdir(@rootPath, (error, files) =>
      if error
        @emit('error', error)
        @emit('done')
      else
        @_processFiles(files)
    )

  _relativePath: (p) ->
    return path.relative(@rootPath, p)

  _emitFile: (fullPath, stats) ->
    @emit('file', fullPath, stats, @_relativePath(fullPath))

  _emitDirectory: (fullPath, stats) ->
    @emit('directory', fullPath, stats, @_relativePath(fullPath))

  _emitError: (error) ->
    @emit('error', error)

  _processFiles: (files) ->
    self = @

    processFile = (childPath, callback) ->
      fs.stat(childPath, (error, stats) ->
        if error
          self._emitError(error)
          callback(error)
        else if stats.isFile()
          self._emitFile(childPath, stats)
          callback()
        else if stats.isDirectory()
          self._emitDirectory(childPath, stats)
          fs.readdir(childPath, (error, files) ->
            if error
              self._emitError(error)
              callback(error)
            else
              for file in files
                self.unshift(
                  func: processFile
                  args: [ path.join(childPath, file) ]
                )
              callback()
          )
        else
          callback()
      )

    for file in files
      self.push(
        func: processFile
        args: [ path.join(self.rootPath, file) ]
      )

module.exports = FSWalker
